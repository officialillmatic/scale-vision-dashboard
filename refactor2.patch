diff -ruN '--exclude=.env' prev/src/App.tsx scale-vision-dashboard-main/src/App.tsx
--- prev/src/App.tsx	2025-10-13 02:07:12.000000000 +0000
+++ scale-vision-dashboard-main/src/App.tsx	2025-10-13 15:47:19.667312154 +0000
@@ -28,12 +28,21 @@
 import SuperAdminCreditsNew from '@/pages/SuperAdminCreditsNew';
 import PricingPage from '@/pages/PricingPage'; // ‚úÖ YA ESTABA
 import PaymentAdminConfigPage from '@/pages/PaymentAdminConfigPage'; // ‚úÖ ACTUALIZADO: Stripe ‚Üí Payment
+// Wrap routes in an error boundary to gracefully handle unexpected exceptions
+import { ErrorBoundary } from '@/components/common/ErrorBoundary';
 
 const queryClient = new QueryClient();
 
 function AppRoutes() {
   return (
     <div className="min-h-screen bg-background">
+      {/*
+        Wrap the entire routes tree in an ErrorBoundary. If any child component
+        throws during render, lifecycle methods, or constructors, the boundary
+        will catch the error and display a friendly fallback UI instead of
+        crashing the whole app.
+      */}
+      <ErrorBoundary>
       <Routes>
         {/* Public landing page - shows for everyone */}
         <Route path="/" element={<Index />} />
@@ -161,6 +170,7 @@
           } 
         />
       </Routes>
+      </ErrorBoundary>
     </div>
   );
 }
diff -ruN '--exclude=.env' prev/src/constants.ts scale-vision-dashboard-main/src/constants.ts
--- prev/src/constants.ts	1970-01-01 00:00:00.000000000 +0000
+++ scale-vision-dashboard-main/src/constants.ts	2025-10-13 15:47:14.739332598 +0000
@@ -0,0 +1,26 @@
+// Centralised constants for RPC names, table names and other repeated strings.
+// Use these constants instead of hard-coded strings throughout the app to avoid typos.
+
+export const RPC = {
+  /**
+   * Supabase RPC function for deducting balance from a user.
+   * See supabase/sql/universal_balance_deduction.sql for implementation.
+   */
+  UNIVERSAL_BALANCE_DEDUCTION: 'universal_balance_deduction',
+
+  /**
+   * RPC function used to fetch users with low balance who need notifications.
+   */
+  GET_USERS_NEEDING_NOTIFICATION: 'get_users_needing_notification',
+};
+
+export const TABLES = {
+  /** Table storing user credit balances. */
+  USER_CREDITS: 'user_credits',
+  /** Table that links users to their assigned agents. */
+  USER_AGENT_ASSIGNMENTS: 'user_agent_assignments',
+  /** Table storing call records. */
+  CALLS: 'calls',
+  /** Agents table for custom and retell agents. */
+  AGENTS: 'agents',
+};
diff -ruN '--exclude=.env' prev/src/pages/DashboardPage.tsx scale-vision-dashboard-main/src/pages/DashboardPage.tsx
--- prev/src/pages/DashboardPage.tsx	2025-10-13 02:07:12.000000000 +0000
+++ scale-vision-dashboard-main/src/pages/DashboardPage.tsx	2025-10-13 15:48:11.011112675 +0000
@@ -1,5 +1,8 @@
 import React, { useState, useEffect } from "react";
 import { supabase } from "@/integrations/supabase/client";
+// Centralised logger and constants
+import { log, error as logError } from '@/utils/logger';
+import { RPC, TABLES } from '@/constants';
 import { DashboardLayout } from "@/components/dashboard/DashboardLayout";
 import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
 import { Badge } from "@/components/ui/badge";
@@ -34,7 +37,7 @@
 import { useNotifications } from '@/hooks/useNotifications';
 
 // ============================================================================
-// FUNCI√ìN UNIVERSAL DE DESCUENTO DE BALANCE
+// UNIVERSAL BALANCE DEDUCTION
 // ============================================================================
 const universalBalanceDeduction = async (
   userId: string,
@@ -43,63 +46,59 @@
   description?: string
 ): Promise<{ success: boolean; oldBalance?: number; newBalance?: number; error?: string; }> => {
   try {
-    console.log(`üí≥ [UNIVERSAL] Descuento: Usuario ${userId}, Monto $${amount}`);
-    
-    const { data, error } = await supabase.rpc('universal_balance_deduction', {
+    log(`üí≥ [UNIVERSAL] Deducting: user ${userId}, amount $${amount}`);
+
+    const { data, error } = await supabase.rpc(RPC.UNIVERSAL_BALANCE_DEDUCTION, {
       p_user_id: userId,
       p_amount: amount,
       p_call_id: callId || null,
-      p_description: description || `Balance deduction ${callId ? `for call ${callId}` : ''}`
+      p_description: description || `Balance deduction ${callId ? `for call ${callId}` : ''}`,
     });
 
     if (error) {
-      console.error('‚ùå [UNIVERSAL] Error en RPC:', error);
+      logError('‚ùå [UNIVERSAL] RPC error:', error);
       return { success: false, error: error.message };
     }
 
     if (!data.success) {
-      console.error('‚ùå [UNIVERSAL] Error en funci√≥n:', data.error);
+      logError('‚ùå [UNIVERSAL] Function error:', data.error);
       return { success: false, error: data.error };
     }
 
-    console.log(`‚úÖ [UNIVERSAL] Descuento exitoso: $${data.old_balance} ‚Üí $${data.new_balance}`);
+    log(`‚úÖ [UNIVERSAL] Deduction success: $${data.old_balance} ‚Üí $${data.new_balance}`);
     return {
       success: true,
       oldBalance: data.old_balance,
-      newBalance: data.new_balance
+      newBalance: data.new_balance,
     };
-
-  } catch (error: any) {
-    console.error('üí• [UNIVERSAL] Excepci√≥n:', error);
-    return { success: false, error: error.message };
+  } catch (err: any) {
+    logError('üí• [UNIVERSAL] Exception:', err);
+    return { success: false, error: err.message };
   }
 };
 
 // ============================================================================
-// FUNCI√ìN PARA REFRESCAR BALANCE DE CR√âDITOS
+// REFRESH CREDIT BALANCE
 // ============================================================================
 const refreshCreditBalance = async (userId: string) => {
   try {
-    console.log('üîÑ Refrescando balance de cr√©ditos en dashboard...');
-    
+    log('üîÑ Refreshing credit balance in dashboard...');
+
     const { data: creditData, error } = await supabase
-      .from('user_credits')
+      .from(TABLES.USER_CREDITS)
       .select('current_balance')
       .eq('user_id', userId)
       .single();
 
     if (error) {
-      console.error('‚ùå Error obteniendo balance actualizado:', error);
+      logError('‚ùå Error fetching updated balance:', error);
       return;
     }
 
-    console.log(`‚úÖ Balance verificado: $${creditData.current_balance}`);
-    
-    // El componente CreditBalance se actualizar√° autom√°ticamente
-    // ya que probablemente use su propio hook para obtener los datos
-    
-  } catch (error) {
-    console.error('üí• Excepci√≥n refrescando balance:', error);
+    log(`‚úÖ Balance verified: $${creditData.current_balance}`);
+    // The CreditBalance component will automatically refresh via its own hook.
+  } catch (err) {
+    logError('üí• Exception refreshing balance:', err);
   }
 };
 
@@ -161,7 +160,7 @@
 // ============================================================================
 const processUnprocessedCalls = async (userId: string) => {
   try {
-    console.log('üîÑ DASHBOARD: Procesando llamadas pendientes...');
+    log('üîÑ DASHBOARD: Processing pending calls...');
     
     if (!userId) {
       alert('‚ùå Usuario no identificado');
@@ -170,7 +169,7 @@
 
     // Obtener agentes del usuario con sus tarifas
     const { data: userAgents, error: agentsError } = await supabase
-      .from('user_agent_assignments')
+      .from(TABLES.USER_AGENT_ASSIGNMENTS)
       .select(`
         agent_id,
         agents!inner (
@@ -184,16 +183,16 @@
       .eq('is_primary', true);
 
     if (agentsError || !userAgents || userAgents.length === 0) {
-      console.error('‚ùå Error obteniendo agentes del usuario:', agentsError);
+      logError('‚ùå Error fetching user agents:', agentsError);
       return { success: false, message: 'No se encontraron agentes asignados' };
     }
 
     const userAgentIds = userAgents.map(assignment => assignment.agents.id);
-    console.log('üë§ Agentes del usuario:', userAgentIds);
+    log('üë§ User agents:', userAgentIds);
 
     // Buscar llamadas completadas sin costo asignado
     const { data: unprocessedCalls, error: callsError } = await supabase
-      .from('calls')
+      .from(TABLES.CALLS)
       .select(`
         id,
         call_id,
@@ -209,16 +208,16 @@
       .limit(10); // Procesar m√°ximo 10 llamadas por vez
 
     if (callsError) {
-      console.error('‚ùå Error obteniendo llamadas:', callsError);
+      logError('‚ùå Error fetching calls:', callsError);
       return { success: false, message: 'Error obteniendo llamadas' };
     }
 
     if (!unprocessedCalls || unprocessedCalls.length === 0) {
-      console.log('‚úÖ No hay llamadas pendientes de procesar');
+      log('‚úÖ No pending calls to process');
       return { success: true, message: 'No hay llamadas pendientes', processed: 0 };
     }
 
-    console.log(`üéØ Encontradas ${unprocessedCalls.length} llamadas para procesar`);
+    log(`üéØ Found ${unprocessedCalls.length} calls to process`);
 
     let processedCount = 0;
     let errors = 0;
     